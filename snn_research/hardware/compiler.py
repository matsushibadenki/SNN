# ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹: snn_research/hardware/compiler.py
# Title: ãƒ‹ãƒ¥ãƒ¼ãƒ­ãƒ¢ãƒ¼ãƒ•ã‚£ãƒƒã‚¯ãƒ»ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© (Phase 6: Hardware Deployment)
# Description:
# - PyTorchãƒ¢ãƒ‡ãƒ«ã‚’ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢å‘ã‘ã®å½¢å¼ã«å¤‰æ›ãƒ»ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã€‚
# - Phase 6å¯¾å¿œ: CUDAã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚«ãƒ¼ãƒãƒ«ç”Ÿæˆã€Verilog HDLç”Ÿæˆæ©Ÿèƒ½ã‚’è¿½åŠ ã€‚

import torch
import torch.nn as nn
import logging
import json
import os
import yaml
from typing import Dict, Any, List, cast, Optional

from .hdl_templates import LIF_NEURON_VERILOG, STDP_LEARNING_VERILOG, CUDA_KERNEL_TEMPLATE

logger = logging.getLogger(__name__)


class NeuromorphicCompiler:
    """
    Brain v2.0 ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ‹ãƒ¥ãƒ¼ãƒ­ãƒ¢ãƒ«ãƒ•ã‚£ãƒƒã‚¯ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢å‘ã‘ã«å¤‰æ›ã™ã‚‹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã€‚
    æ©Ÿèƒ½:
    1. é‡ã¿ã®é‡å­åŒ– (Float32 -> Int8)
    2. ã‚¹ãƒ‘ã‚¤ã‚¯æ´»å‹•ã«åŸºã¥ãã‚³ã‚¢ãƒ»ãƒžãƒƒãƒ”ãƒ³ã‚°ã®æœ€é©åŒ–
    3. ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹çŽ‡ã®æŽ¨å®š
    4. [Phase 6] CUDAã‚«ãƒ¼ãƒãƒ«ç”Ÿæˆ
    5. [Phase 6] Verilog HDLç”Ÿæˆ (FPGA/ASIC)
    """

    def __init__(self, target_hardware: str = "Loihi2_Sim"):
        self.target = target_hardware
        self.supported_layers = (nn.Linear, nn.Conv2d, nn.Conv1d)
        logger.info(
            f"ðŸ”§ Neuromorphic Compiler initialized for target: {target_hardware}")

    def compile(self, model: nn.Module, output_path: Optional[str] = None) -> Dict[str, Any]:
        """
        ãƒ¢ãƒ‡ãƒ«ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã€ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãƒžãƒƒãƒ”ãƒ³ã‚°æƒ…å ±ã‚’ç”Ÿæˆã™ã‚‹ã€‚
        """
        compiled_stats: Dict[str, Any] = {
            "total_neurons": 0,
            "total_synapses": 0,
            "quantized_layers": [],
            "estimated_power_mW": 0.0,
            "target": self.target
        }

        for name, layer in model.named_modules():
            if isinstance(layer, (nn.Linear, nn.Conv2d)):
                layer_stats = self._quantize_layer(layer, name)
                cast(List[Any], compiled_stats["quantized_layers"]).append(
                    layer_stats)

                current_neurons = cast(int, compiled_stats["total_neurons"])
                compiled_stats["total_neurons"] = current_neurons + \
                    layer_stats["neurons"]

                current_synapses = cast(int, compiled_stats["total_synapses"])
                compiled_stats["total_synapses"] = current_synapses + \
                    layer_stats["synapses"]

        total_neurons = cast(int, compiled_stats["total_neurons"])
        total_synapses = cast(int, compiled_stats["total_synapses"])

        num_cores = (total_neurons // 1024) + 1

        # Power estimation (very rough)
        static_power = num_cores * 0.5  # mW per core
        dynamic_power = total_synapses * 0.0001  # ç°¡æ˜“è¨ˆç®—

        compiled_stats["estimated_power_mW"] = static_power + dynamic_power
        compiled_stats["core_mapping"] = {"required_cores": num_cores}

        # çµæžœã®ä¿å­˜
        if output_path:
            try:
                os.makedirs(os.path.dirname(output_path), exist_ok=True)
                with open(output_path, 'w') as f:
                    if output_path.endswith('.yaml') or output_path.endswith('.yml'):
                        yaml.dump(compiled_stats, f, sort_keys=False)
                    else:
                        json.dump(compiled_stats, f, indent=4)
                logger.info(
                    f"ðŸ’¾ Compiled hardware manifest saved to: {output_path}")
            except Exception as e:
                logger.error(f"âŒ Failed to save compiled manifest: {e}")

        return compiled_stats

    def export_to_cuda(self, model: nn.Module, output_dir: str):
        """
        [Phase 6] ãƒ¢ãƒ‡ãƒ«ã‚’CUDAã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚«ãƒ¼ãƒãƒ«ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã€‚
        """
        os.makedirs(output_dir, exist_ok=True)
        cuda_src_path = os.path.join(output_dir, "snn_kernels.cu")
        
        try:
            with open(cuda_src_path, "w") as f:
                f.write("// Generated by SNN Neuromorphic Compiler (Phase 6)\n")
                f.write(CUDA_KERNEL_TEMPLATE)
            
            logger.info(f"ðŸš€ CUDA kernels exported to: {cuda_src_path}")
            # ã“ã“ã§å®Ÿéš›ã®é‡ã¿ãƒ‡ãƒ¼ã‚¿ç­‰ã‚’ãƒã‚¤ãƒŠãƒªã¨ã—ã¦æ›¸ãå‡ºã™å‡¦ç†ãŒå…¥ã‚‹æƒ³å®š
            
        except Exception as e:
            logger.error(f"âŒ Failed to export CUDA kernels: {e}")

    def export_to_verilog(self, model: nn.Module, output_dir: str):
        """
        [Phase 6] ãƒ¢ãƒ‡ãƒ«ã‚’Verilog HDLãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã€‚
        FPGAã‚„ASICè¨­è¨ˆã«ä½¿ç”¨å¯èƒ½ã€‚
        """
        os.makedirs(output_dir, exist_ok=True)
        hdl_path = os.path.join(output_dir, "snn_core.v")

        try:
            with open(hdl_path, "w") as f:
                f.write("// Generated by SNN Neuromorphic Compiler (Phase 6)\n")
                f.write("// Module: SNN Core Logic\n\n")
                
                f.write(LIF_NEURON_VERILOG)
                f.write("\n")
                f.write(STDP_LEARNING_VERILOG)
                f.write("\n")
                
                f.write("// Top Module Definition Placeholder\n")
                f.write("module snn_top(\n")
                f.write("    input clk,\n")
                f.write("    input rst_n,\n")
                f.write("    input [7:0] sensory_input,\n")
                f.write("    output [7:0] motor_output\n")
                f.write(");\n")
                f.write("    // Interconnects and Neuron instantiations would go here\n")
                f.write("endmodule\n")

            logger.info(f"âš¡ Verilog HDL exported to: {hdl_path}")
            
        except Exception as e:
            logger.error(f"âŒ Failed to export Verilog HDL: {e}")

    def _quantize_layer(self, layer: nn.Module, name: str) -> Dict[str, Any]:
        if not hasattr(layer, 'weight') or not isinstance(layer.weight, torch.Tensor):
            return {"neurons": 0, "synapses": 0, "bits": 0}

        weight = layer.weight
        weight_shape = weight.shape

        neurons = weight_shape[0]
        synapses = weight.numel()

        return {
            "name": name,
            "neurons": neurons,
            "synapses": synapses,
            "w_min": weight.min().item(),
            "w_max": weight.max().item(),
            "bits": 8  # target 8bit
        }

    def _save_manifest(self, model_name: str, stats: Dict[str, Any]):
        os.makedirs("workspace/deployment", exist_ok=True)
        path = f"workspace/deployment/{model_name}_manifest.json"
        with open(path, "w") as f:
            json.dump(stats, f, indent=4)
        logger.info(f"ðŸ“„ Deployment manifest saved to {path}")